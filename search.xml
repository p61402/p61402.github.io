<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[挑戰LeetCode Weekly Contest 49]]></title>
    <url>%2F2017%2F09%2F10%2F%E6%8C%91%E6%88%B0LeetCode-Weekly-Contest-49%2F</url>
    <content type="text"><![CDATA[三度挑戰這次的題目，前兩題真的簡單，至於後兩題，真心難QQ ，最終成績 753 / 2362。 第1題 674. Longest Continuous Increasing Subsequence問題給一個未排序的整數陣列，找出最長的連續遞增子序列的長度。 輸入範例 1[1,3,5,4,7] 輸出範例 13 輸入範例 2[2,2,2,2,2] 輸出範例 21 方法遞增序列的特性就是較晚出現的元素一定大於較先出現的元素，遍歷整個陣列，因為要求為「連續」，所以只要遇到不符合遞增條件的元素，就要重新計算。 1234567891011121314class Solution(object): def findLengthOfLCIS(self, nums): if not nums: return 0 maximum = 1 current = 1 for i in range(1, len(nums)): if nums[i - 1] &lt; nums[i]: current += 1 else: maximum = max(maximum, current) current = 1 maximum = max(maximum, current) return maximum 第2題 676. Implement Magic Dictionary問題定義一個陣列，由許多字串組成，輸入一個字串，若陣列中任一字串更改一個字母後，與輸入的字串相同，回傳True，反之則回傳False。 輸入與輸出Input: buildDict([&quot;hello&quot;, &quot;leetcode&quot;]), Output: Null Input: search(&quot;hello&quot;), Output: False Input: search(&quot;hhllo&quot;), Output: True Input: search(&quot;hell&quot;), Output: False Input: search(&quot;leetcoded&quot;), Output: False 方法這題沒有什麼特殊的技巧，只要將輸入字串與陣列內的字串一一比對即可。 1234567891011121314151617181920class MagicDictionary(object): def __init__(self): self.magic = [] def buildDict(self, dic): self.magic = dic def search(self, word): for m in self.magic: modify = 0 if len(m) == len(word): for i in range(len(m)): if m[i] != word[i]: modify += 1 if modify == 1: return True return False 第3題 675. Cut Off Trees for Golf Event問題輸入一個二維陣列，0代表無法通過的障礙物，1代表可以通行的草皮，大於1的數代表一棵樹，同樣可以通行，數字大小代表樹的高度。今天我們要根據樹的高度由低到高進行修剪，經過修剪後的樹會變成草皮，我們要從(0, 0)出發，依序走訪所有的樹，輸出修剪所有的樹所需經過最短的距離，若有任何一棵樹無法抵達，則輸出-1。 輸入與輸出Input: [ [1,2,3], [0,0,4], [7,6,5] ] Output: 6 Input: [ [1,2,3], [0,0,0], [7,6,5] ] Output: -1 Input: [ [2,3,4], [0,0,5], [8,7,6] ] Output: 6 Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking. 方法我先將所有非0或1的數加入一個陣列中，將其排序後由小至大取出，利用BFS計算從目前位置到各點的最短距離，取出目前位置到欲修剪的距離。很不幸的我的方法吃了一發 TLE ，應該是做的 BFS 有太多多餘的範圍了，應該只要找出目前位置到目的地的最短距離就好，之後若有時間再想辦法補上新的方法吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution(object): def cutOffTree(self, forest): import math self.forest = forest self.r, self.c = len(self.forest), len(self.forest[0]) f = [col for row in forest for col in row if col != 0 and col != 1] f.sort(reverse=True) total_step = 0 cur_pos = (0, 0) while f: self.num_step = [[math.inf for j in range(self.c)] for i in range(self.r)] self.num_step[cur_pos[0]][cur_pos[1]] = 0 self.min_step(cur_pos) next_cut = f.pop() next_pos = self.find_pos(next_cut) if not self.num_step[next_pos[0]][next_pos[1]] &lt; math.inf: return -1 total_step += self.num_step[next_pos[0]][next_pos[1]] cur_pos = next_pos return total_step def min_step(self, pos): i, j = pos[0], pos[1] # print(i, j, self.num_step[i][j]) if not (0 &lt;= i &lt; self.r and 0 &lt;= j &lt; self.c): return if 0 &lt;= i - 1 &lt; self.r and 0 &lt;= j &lt; self.c and self.forest[i - 1][j]: if self.num_step[i - 1][j] &gt;= self.num_step[i][j] + 1: self.num_step[i - 1][j] = self.num_step[i][j] + 1 self.min_step((i - 1, j)) if 0 &lt;= i + 1 &lt; self.r and 0 &lt;= j &lt; self.c and self.forest[i + 1][j]: if self.num_step[i + 1][j] &gt;= self.num_step[i][j] + 1: self.num_step[i + 1][j] = self.num_step[i][j] + 1 self.min_step((i + 1, j)) if 0 &lt;= i &lt; self.r and 0 &lt;= j - 1 &lt; self.c and self.forest[i][j - 1]: if self.num_step[i][j - 1] &gt;= self.num_step[i][j] + 1: self.num_step[i][j - 1] = self.num_step[i][j] + 1 self.min_step((i, j - 1)) if 0 &lt;= i &lt; self.r and 0 &lt;= j + 1 &lt; self.c and self.forest[i][j + 1]: if self.num_step[i][j + 1] &gt;= self.num_step[i][j] + 1: self.num_step[i][j + 1] = self.num_step[i][j] + 1 self.min_step((i, j + 1)) def find_pos(self, num): for i in range(len(self.forest)): if num in self.forest[i]: return (i, self.forest[i].index(num)) return -1 第4題 673. Number of Longest Increasing Subsequence問題給一個未排序的整數陣列，找出最長的遞增子序列的數量。 輸入與輸出Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7]. Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences&apos; length is 1, so output 5. 方法計算LIS的長度有兩種思維方式，第一種是找出哪些數字能接在nums[i]後面，第二種是找出nums[i]能接在哪些數字後面，這裡採用第二種方法。 這裡需要用到兩個陣列： LIS: LIS[i]代表以nums[i]結束的最長遞增子序列的長度 cnt: cnt[i]代表以nums[i]結束的最長遞增子序列的數量 假設nums[i]能接在nums[j]後面，代表nums[i] &gt; nums[j]，這裡有三種狀況可以討論： LIS[i] &gt; LIS[j] + 1 : nums[i]接在 nums[j]後面比原本還要短，不接 LIS[i] = LIS[j] + 1 : nums[i]接在 nums[j]後面比跟原本一樣長，只要把數量相加就好 LIS[i] &lt; LIS[j] + 1 : nums[i]接在 nums[j]後面比原本還要長，長度加1，繼承前面的數量 最後將所有LIS[i]為最大值所對應的cnt[i]相加即為答案。 123456789101112131415161718class Solution: def findNumberOfLIS(self, nums): if nums == []: return 0 # 初始化陣列，每個數字本身就是長度為1的LIS LIS, cnt = [1] * len(nums), [1] * len(nums) # nums[i]能接在哪些數字後面 for i in range(1, len(nums)): for j in range(0, i): if nums[i] &gt; nums[j]: if LIS[i] == LIS[j] + 1: cnt[i] += cnt[j] elif LIS[i] &lt; LIS[j] + 1: cnt[i] = cnt[j] LIS[i] = LIS[j] + 1 return sum((y for x, y in zip(LIS, cnt) if x == max(LIS)))]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>LeetCode Weekly Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二元樹(Binary Tree)]]></title>
    <url>%2F2017%2F09%2F08%2F%E4%BA%8C%E5%85%83%E6%A8%B9-Binary-Tree%2F</url>
    <content type="text"><![CDATA[樹 Tree生活中常見各式各樣的數狀圖，像是族譜、賽程表等等，至於在計算機科學中，tree則是一種抽象資料型別(Abstract Data Type)，是一種具有階層式 (Hierarchical) 的數狀資料集合。 定義樹 (tree) 是一個由一個或多個節點 (node) 所組成的集合，滿足以下兩點： 有一個特別的節點叫作「根」(root) 其餘的節點 (node) 可被分割為 n &gt;= 0 個互斥 (disjoint) 的集合 T1, ..., Tn , 每個集合都是一棵樹，並且稱作根的「子樹」 (subtree) 名詞介紹 degree : 一個 node 子節點的個數，e.g. degree(A) = 3, degree(C) = 1, degree(F) = 0 leaf (terminal) : degree = 0 的 node，e.g. leaf = {K, L, F, G, M, I, J} parent &amp; children : A 是 B 的 parent, B 是 A 的 children siblings : 具有相同 parent 的 nodes, e.g. B, C, D 是 siblings degree of tree : 所有 node 的 degree 中最大值代表這棵數的 degree，degree 為 k 的樹又稱為 k-ary tree ancestors : 一個 node 走回 root 所要經過的 nodes, e.g. M 的 ancestors 有 A, D, H level : root 的 level 為 0 或 1，children 的 level 為 root 的 level + 1，以此類推 height (depth) : 所有 node 中 level 的最大值代表這棵數的 height (depth) 表示方法 List Representation Left Child-Right Sibling Representation Representation as Degree-Two Tree (Left Child-Right Child) 二元樹 Binary Tree以上介紹的tree並沒有限制subtree的數量，但我們一般較常用的還是接下來要介紹的 (二元樹) Binary Tree 。 二元樹有以下幾點特性： 每個 node 的 degree 不超過 2 binary tree 可以不存在任何的節點 (empty) 需要區分左子樹與右子樹，也就是左右子樹互換位置的話就會形成另一個新的樹 二元樹的表示方法 Array Representation Linked Representation 以下使用python以Linked List實作Binary Tree。 首先定義樹的節點： 12345class TreeNode(): def __init__(self, data=None, left=None, right=None): self.data = data self.left = left self.right = right 接著是二元樹的類別以及基本方法： 12345678910111213141516class BinaryTree(): def __init__(self, root=None): self.root = root def isEmpty(self, node): return node is None def left_child(self, node): if self.isEmpty(node): return return node.left def right_child(self, node): if self.isEmpty(node): return return node.right 二元樹的遍歷 Traversal Inorder Traversal12345def inorder(self, node): if node: self.inorder(node.left) print(node.data, end=" ") self.inorder(node.right) Preorder Traversal 12345def preorder(self, node): if node: print(node.data, end=" ") self.preorder(node.left) self.preorder(node.right) Postorder Traversal 12345def postorder(self, node): if node: self.postorder(node.left) self.postorder(node.right) print(node.data, end=" ") Level-Order Traversal 12345678910111213def levelorder(self, node): if not node: return from collections import deque queue = deque() queue.append(node) while queue: node = queue.popleft() print(node.data, end=" ") if node.left: queue.append(node.left) if node.right: queue.append(node.right) 其他操作 複製 12345# Return a Pointer to a same data from original nodedef copy(self, node): if node: return TreeNode(node.data, self.copy(node.left), self.copy(node.right)) return None 相等 1234@staticmethoddef equal(first, second): return (not first and not second) or (first and second and (first.data == second.data) \and BinaryTree.equal(first.left, second.left) and BinaryTree.equal(first.right, second.right)) (未完成，待補上...)]]></content>
      <categories>
        <category>學校課程</category>
        <category>資料結構</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Data Structure</tag>
        <tag>Tree</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆疊(Stack)與佇列(Queue)]]></title>
    <url>%2F2017%2F09%2F06%2F%E5%A0%86%E7%96%8A-Stack-%E8%88%87%E4%BD%87%E5%88%97-Queue%2F</url>
    <content type="text"><![CDATA[介紹Stack 與 Queue 都是一種 抽象資料型別 (Abstract Data Type)，兩者的區別簡單來說就是Stack是 Last-In-First-Out (LIFO)，而 Queue 則是 First-In-First-Out (FIFO)。 實作以下用 Linked List 來實作 Stack 與 Queue Stack首先是 stack 的節點。 1234class StackNode(): def __init__(self, value=None, next=None): self.value = value self.next = None 接著定義函式，因為是後進先出，所以用 top 來紀錄最後進入的數，因此不管是 push 還是 pop 都是更動到 top 的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Stack(): def __init__(self, top=None): self.top = top def print_nodes(self): current = self.top while current: end = " -&gt; " if current.next else "\n" print(current.value, end=end) current = current.next def push(self, value): old_top = self.top self.top = StackNode(value, old_top) self.top.next = old_top def pop(self): if self.isEmpty(): print("Pop nothing, the stack is empty!") return self.top = self.top.next def top_value(self): if self.isEmpty(): return "Nothing at the top, the stack is empty!" return self.top.value def search(self, value): count = 0 current = self.top while current: if current.value == value: return count count += 1 current = current.next def isEmpty(self): return self.top is None def size(self): count = 0 current = self.top while current: count += 1 current = current.next return count Queue接著是 queue 的節點。 1234class QueueNode(): def __init__(self, value=None, next=None): self.value = value self.next = next 因為 queue 為先進先出，因此需要有兩個變數來紀錄頭跟尾的位置，可以將 queue 想像成排隊的時候，add 就是將新的節點接在隊伍的後方，delete 則是將節點從隊伍的頭移除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Queue(): def __init__(self, front=None, rear=None): self.front = front self.rear = rear def print_queue(self): current = self.front while current: end = " -&gt; " if current.next else "\n" print(current.value, end=end) current = current.next def add(self, value): if self.isEmpty(): self.front = QueueNode(value) self.rear = self.front else: self.rear.next = QueueNode(value) self.rear = self.rear.next def delete(self): if self.isEmpty(): print("Delete nothing, the queue is empty.") else: self.front = self.front.next def search(self, value): count = 0 current = self.front while current: if current.value == value: return count count += 1 current = current.next def top_value(self): if self.isEmpty(): return "Nothing at the top, the stack is empty!" return self.front.value def end_value(self): if self.isEmpty(): return "Nothing at the end, the stack is empty!" return self.rear.value def isEmpty(self): return self.front is None 程式碼：Stack Queue]]></content>
      <categories>
        <category>學校課程</category>
        <category>資料結構</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Data Structure</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#167 Two Sum II - Input array is sorted feat. Two Pointers]]></title>
    <url>%2F2017%2F09%2F05%2FLeetCode-167-Two-Sum-II-Input-array-is-sorted-feat-Two-Pointers%2F</url>
    <content type="text"><![CDATA[問題給定一個遞增的整數陣列nums(已排序)，其中有兩個數的和會等於目標target，回傳他們的位置，且同個位置不能重複選取。 輸入numbers = [2, 7, 11, 15] target = 9 輸出[1, 2] 方法這題是LeetCode#1 Two Sums的改版，差別是這題輸入的陣列已經經過排序了，這題還是可以用hash table來解，不過這裡我們要用比較不一樣的方法，叫作two pointers 。 two pointers在這裡的使用方法，就是兩個箭頭分別指向陣列的頭跟尾，藉由將左邊的箭頭向右調整以及右邊的箭頭向左調整，逼近出所要求的值。 12345678910class Solution(object): def twoSum(self, numbers, target): left, right = 0, len(numbers) - 1 while left &lt; right: if numbers[left] + numbers[right] &lt; target: left += 1 elif numbers[left] + numbers[right] &gt; target: right -= 1 else: return [left + 1, right + 1] 以下的問題也常常用two pointers來解： 字串、陣列反轉 兩個跑者一快一慢在操場上奔馳，問兩人何時相遇 字串回文(Palindrome)]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挑戰LeetCode Weekly Contest 48]]></title>
    <url>%2F2017%2F09%2F04%2F%E6%8C%91%E6%88%B0LeetCode-Weekly-Contest-48%2F</url>
    <content type="text"><![CDATA[再度挑戰這次的題目稍稍比上次簡單一點，前兩題解完大概還剩 20 分鐘，看看第三題好像也不難，但可惜還是沒寫完，最終成績 1170 / 2668，嗯...好像沒進步 Orz 。 第1題 671. Second Minimum Node In a Binary Tree問題給一棵二元樹，每一個node的子節點不是 0 個就是 2 個，輸出所有節點當中第二小的值，若不存在則輸出-1。 輸入tree 的 root 範例： 2 / \ 2 5 / \ 5 7 輸出5 方法遍歷所有的節點，不斷刷新最小值(下界)與第二小的值(上界)，夾擠出真正第二小的數值。 1234567891011121314151617181920212223class Solution(object): def findSecondMinimumValue(self, root): if not root or not root.left: return -1 self.smallest = root.val self.second = max(root.left.val, root.right.val) self.find(root) if self.smallest == self.second: return -1 return self.second def find(self, root): if root.left and root.right: if root.left.val &lt; self.smallest: self.smallest = root.left.val if root.right.val &lt; self.smallest: self.smallest = root.right.val if root.left.val &gt; self.smallest and root.left.val &lt;= self.second: self.second = root.left.val if root.right.val &gt; self.smallest and root.right.val &lt;= self.second: self.second = root.right.val self.find(root.left) self.find(root.right) 第2題 669. Trim a Binary Search Tree問題給一個 binary search tree，以及正整數 L 與 R (L &lt;= R)，修剪這棵樹使得所有節點的值介於 [L, R] 。 輸入tree 的 root 以及 L 與 R 的值 範例： 3 / \ 0 4 \ 2 / 1 L = 1 R = 2 輸出新的 tree 的 root 3 / 2 / 1 方法利用二元搜尋樹的特性，左子樹的值一定小於等於 root 的值，右子樹的值一定大於等於 root 的值。因此遍歷每一個節點，若 root 的值小於 L ，捨棄左子樹；若 root 的值大於 R ，捨棄右子樹。 1234567891011class Solution(object): def trimBST(self, root, L, R): if not root: return None if L &gt; root.val: return self.trimBST(root.right, L, R) elif R &lt; root.val: return self.trimBST(root.left, L, R) root.left = self.trimBST(root.left, L, R) root.right = self.trimBST(root.right, L, R) return root 第3題 670. Maximum Swap問題給一個非負整數，問交換任兩個digit的位置所能得到的最大值為何？給的值範圍介於 [0, 108] 之間。 輸入2736 輸出7236 方法範圍介於 [0, 108] ，代表最多有 8 個digit，任選兩個的可能性只有 28 種，直接用暴力法窮舉所有的可能性。 12345678910class Solution(object): def maximumSwap(self, num): maximum = num n = list(str(num)) for i in range(len(n) - 1): for j in range(i + 1, len(n)): new_num = int("".join(n[0:i] + list(n[j]) + n[i+1:j] + list(n[i]) + n[j+1:])) if new_num &gt; maximum: maximum = new_num return maximum 第4題 672. Bulb Switcher II問題給兩個正整數n與m，分別代表燈泡的數量以及操作開關的次數，n 個燈泡依序標記為 1, 2, 3,..., n ，一開始所有的燈泡都是打開的。有以下四種操作開關的方法： 按下所有開關 按下編號為偶數的開關 按下編號為奇數的開關 按下編號為(3k+1)的開關, k = 0, 1, 2, ... 問 n 個燈泡在操作 m 次之後，這些開關的狀態有哪些的可能性。 輸入n = 3, m = 1. 輸出4 方法3 個燈泡在操作 1 次後可能的狀態為： [off, on, off], [on, off, on], [off, off, off], [off, on, on]. 一開始想說用遞迴來解，枚舉所有的可能，但是居然 TLE ，太可惡了！ 1234567891011121314151617class Solution(object): def flipLights(self, n, m): self.lights = [True for i in range(n)] self.times = m self.status = [] self.flipping(self.lights, 0) return len(self.status) def flipping(self, light, time): if time == self.times: if light not in self.status: self.status.append(light) return self.flipping([not v for v in light], time + 1) self.flipping([not v if (i + 1) % 2 == 0 else v for i, v in enumerate(light)], time + 1) self.flipping([not v if (i + 1) % 2 == 1 else v for i, v in enumerate(light)], time + 1) self.flipping([not v if (i + 1) % 3 == 1 else v for i, v in enumerate(light)], time + 1) 果然 O(2n) 還是行不通嗎，但是請仔細觀察可能的狀態，就會發現最多的可能只有八種。 n = 1, m = 0 [on] n = 1, m &gt;= 1 [on], [off] -------------- n = 2, m = 0 [on, on] n = 2, m = 1 [off, off], [on, off], [off, on] n = 2, m &gt;= 2 [on, on], [off, off], [on, off], [off, on] ------------------------------------------- n = 3, m = 0 [on, on, on] n = 3, m = 1 [off, off, off], [on, off, on], [off, on, off], [off, on, on] n = 3, m = 2 [on, on, on], [off, on, off], [on, off, on], [on, off, off], [off, off, off], [off, off, on], [on, on, off] n = 3, m &gt;= 3 [on, on, on], [off, on, off], [on, off, on], [on, off, off], [off, off, off], [off, off, on], [on, on, off], [off, on, on] --------------------------------------------------------------------------------------------------------------------------- n &gt;= 4 的情況都跟 n = 3 相同 因此根據n與m的值可以歸納出以下的結果： 1234567891011class Solution(object): def flipLights(self, n, m): if n == 0 or m == 0: return 1 if n == 1: return 2 if n == 2: return 3 if m == 1 else 4 if m == 1: return 4 return 7 if m == 2 else 8]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>LeetCode Weekly Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[連結串列(Linked List)]]></title>
    <url>%2F2017%2F09%2F02%2F%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97-Linked-List%2F</url>
    <content type="text"><![CDATA[連結串列一般指的是單向連結串列(Single Linked List)，由node所組成，每個node都具有兩種屬性，分別是「資料」以及「指標」。資料是儲存目前這個節點的值，指標是指向下一個節點的連結，至於最後一個結點則會指向null。 連結串列比起一般的陣列，優點是能夠隨著需求動態配置記憶體，插入或移除元素時也相對方便；缺點是取出元素時無法直接指定位置，需要遍歷整個串列。 以下用python來實作Linked List。 首先我們要實作node，宣告一個class名稱ListNode，每個node都需要兩個元素，資料value與指向下一個node的指標next。 1234class ListNode(object): def __init__(self, value=None, next=None): self.val = value self.next = next 我們還要宣告一個名為LinkedList的類別，用來紀錄串列的起始位置。 123class LinkedList(object): def __init__(self, head=None): self.head = head 接著在LinkedList實作下面的方法： print_nodes() at(index) append(value) insert(index, value) removePos(index) remove(value, all=False) indexOf(value) clear() isEmpty() size() 首先是print_nodes方法，走訪所有的節點並印出每個結點的資料。 12345678def print_nodes(self): if not self.head: print(self.head) node = self.head while node: end = " -&gt; " if node.next else "\n" print(node.val, end=end) node = node.next 接著是at方法，回傳index位置的value。 12345678def at(self, index): count = 0 node = self.head while node: if count == index: return node.val count += 1 node = node.next 第三個是append，將值為value的節點接在陣列的最尾端。 12345678def append(self, value): if not self.head: self.head = ListNode(value) return node = self.head while node.next: node = node.next node.next = ListNode(value) 第四個是insert，將value插入index的位置。 123456789101112131415161718def insert(self, index, value): if index &gt;= self.size(): self.append(value) return count = 0 node = self.head previous = None while node: if count == index: if previous: new_node = ListNode(value, previous.next) previous.next = new_node else: self.head = ListNode(value, node) return count += 1 previous = node node = node.next 第五個與第六個是removePos以及remove，分別是移除位置為index的節點，以及移除值為value的節點。 12345678910111213141516def removePos(self, index): count = 0 node = self.head previous = None while node: if count == index: if previous: previous.next = node.next node = node.next else: self.head = node.next node = self.head return else: previous = node node = node.next 12345678910111213141516def remove(self, val, all=False): node = self.head previous = None while node: if node.val == val: if previous: previous.next = node.next node = node.next else: self.head = node.next node = self.head if not all: return else: previous = node node = node.next 第七個是indexOf，回傳第一個出現的value在串列中的的位置。 12345678def indexOf(self, value): node = self.head count = 0 while node: if node.val == value: return count count += 1 node = node.next 最後三個是clear, isEmpty, 以及size。 12def clear(self): self.head = None 12def isEmpty(self): return self.head is None 1234567def size(self): count = 0 node = self.head while node: count += 1 node = node.next return count 程式碼連結]]></content>
      <categories>
        <category>學校課程</category>
        <category>資料結構</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#78 Subsets]]></title>
    <url>%2F2017%2F08%2F31%2FLeetCode-78-Subsets%2F</url>
    <content type="text"><![CDATA[問題給一串元素相異的數列，求由此數列之元素所組成的所有子集合。 輸入[1,2,3] 輸出[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 方法每個元素可以出現或是不出現，每一種組合方法都是一個子集合，所以時間複雜度是O(2n) 。利用Backtracking遞迴枚舉所有可能。 1234567891011121314class Solution(object): def subsets(self, nums): self.length = len(nums) self.ans = [] self.backtrack(nums, []) return(self.ans) def backtrack(self, nums, n): if len(n) == self.length: a = [nums[i] for i, v in enumerate(n) if v] self.ans.append(a) else: self.backtrack(nums, n + [True]) self.backtrack(nums, n + [False]) 其他解法以及類似問題請看這裡。]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#442 Find All Duplicates in an Array]]></title>
    <url>%2F2017%2F08%2F30%2FLeetCode-442-Find-All-Duplicates-in-an-Array%2F</url>
    <content type="text"><![CDATA[問題給一個長度為 n 的整數陣列，裡面的元素由 1~n 所組成，每個數字出現 0~2 次，找出所有出現 2 次的數字。(不使用額外空間且時間複雜度必須為O(n)) 輸入[4, 3, 2, 7, 8, 2, 3, 1] 輸出[2, 3] 方法負號標記法將陣列nums的值遍歷一次，將每個出現過的值當作index，將對應到的num[index]的值乘上-1，若對應到的值已經為負數的話，代表已經出現過 1 次，目前是第 2 次，這樣就能找出所有出現過 2 次的元素了。 123456789class Solution(object): def findDuplicates(self, nums): ans = [] for i in nums: if nums[abs(i) - 1] &lt; 0: ans.append(abs(i)) else: nums[abs(i) - 1] *= -1 return ans #448 Find All Numbers Disappeared in an Array，也可以用同樣的方法來解。]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挑戰LeetCode Weekly Contest 47]]></title>
    <url>%2F2017%2F08%2F28%2F%E6%8C%91%E6%88%B0LeetCode-Weekly-Contest-47%2F</url>
    <content type="text"><![CDATA[前言這次心血來潮報名了 LeetCode 每周都會舉辦的比賽，規則是在1.5小時之內要解出4題，這對我來說是一大挑戰啊！因為以往參加的比賽，時間都是3小時左右，這麼短的時間內要解出4題真的不容易，不過既然都報名了就全力以赴吧！ 第1題 665. Non-decreasing Array問題給定一個長度為 n 的整數陣列，問是否能在最多更改 1 個數的情況下，將陣列變成 non-decreasing array，也就是遞增的陣列。 輸入[4, 2, 3] 輸出True 方法我的策略是分別從頭尾出發走一次，若遇到下一個數 pj 小於/大於目前這個數 pi 的話，就將下一個數的值改為目前這個數，使得目前為止的元素為遞增的狀態，此時修改的次數就會增加一次。若分別從頭尾走，修改的次數都大於一次的話，代表無法符合題目的條件，回傳False，反之回傳True。那為什麼要分別從頭尾走一次呢？ 以範例的輸入當例子，若只從正方向走， (4, 2) 不符合遞增，將 2 改成 4，陣列變成 [4, 4, 3]，接著遇到 (4, 3) 又不符合遞增，因此只修改一個值並不能使原本的陣列變成遞增數列。但是錯啦！其實只要把第一個數 4 改成 1 或 2 就可以了，想到從反方向走的話好像可以達到這個效果，所以必須要檢查兩個方向才能確保沒有漏網之魚。 1234567891011121314151617181920class Solution: def checkPossibility(self, nums): n = list(nums) edit_time_1 = 0 for i in range(len(nums) - 1): if nums[i] &gt; nums[i + 1]: nums[i + 1] = nums[i] edit_time_1 += 1 nums = n edit_time_2 = 0 for i in range(len(nums) - 1, 0, -1): if nums[i] &lt; nums[i - 1]: nums[i - 1] = nums[i] edit_time_2 += 1 if edit_time_1 &lt;= 1 or edit_time_2 &lt;= 1: return True else: return False 第2題 666. Path Sum IV問題輸入為一個 Depth &lt; 5 的 tree，每個 node 可用三位數來表示。 百位數D代表這個 node 所在的深度，1 &lt;= D &lt;= 4 。 十位數P代表這個 node 在這個深度的第幾個位置, 1 &lt;= P &lt;= 8 。 個位數V代表這個 node 的值, 0 &lt;= V &lt;= 9 。 找出所有從 root 到 leaf 的路徑和，也就是把路徑上的值相加。 輸入[113, 215, 221] 輸出12 方法以下是範例輸入的解釋： The tree that the list represents is: 3 / \ 5 1 The path sum is (3 + 5) + (3 + 1) = 12. 先將輸入的點分別對應 1 ~ 15 的值(也就是用陣列表示 tree, 但這裡直接用dictionary比較方便)，接著找出所有的 leaf ，再將每個 leaf 到 root 的路徑上所經過的點全部加起來即可。 1234567891011class Solution: def pathSum(self, nums): order = ['00', '11', '21', '22', '31', '32', '33', '34', '41', '42', '43', '44', '45', '46', '47', '48'] tree = dict([(order.index(str(n)[:2]), n % 10) for n in nums]) summation = 0 leaves = [n for n in tree.keys() if not (2 * n in tree or 2 * n + 1 in tree)] for leaf in leaves: while leaf &gt;= 1: summation += tree[leaf] leaf = int(leaf / 2) return summation 第3題 667. Beautiful Arrangement II問題輸入整數n與k，找到一個由 1 ~ n 組成的陣列[a1, a2, ..., an]，陣列元素不得重複，使得 [|a1-a2|, |a2-a3|, ..., |an-1-an|] 剛好由 k 種不同的數組成。 輸入n = 3, k = 1 輸出[1, 2, 3] 方法這題推導了很久，想到了一個方法，[1, 2, ..., n] 的差有 k 種值，1 &lt;= k &lt;= n - 1，只要建立一個規則產生所有的差，接著再想辦法湊出這個數列，舉例： output: 5 1 4 3 2 diff: 4 3 1 1 假設要使得[1, 2, 3, 4, 5]鄰近的差只有三種，那就先將兩種差設為 n-1 與 n-2，也就是 4 跟 3，剩下的差都填 1 代表第三種差。至於要產生的陣列，先填入最大的數 5，接著根據每個差依序湊出陣列接下來的值，最後就會得到滿足條件的陣列了。 1234567891011121314class Solution: def constructArray(self, n, k): diff = [] for i in range(k - 1): diff.append(n - i - 1) for i in range(n - k): diff.append(1) nums = [n] for i in range(n - 1): new_value = abs(nums[i] + diff[i]) if new_value &gt; n or new_value in nums: new_value = abs(nums[i] - diff[i]) nums.append(new_value) return nums 第4題 668. Kth Smallest Number in Multiplication Table問題找出在一個 m * n 的乘法表中，第 k 小的數字。 輸入m = 3, n = 3, k = 5 輸出3 方法以 3 * 3 的乘法表舉例： The Multiplication Table: 1 2 3 2 4 6 3 6 9 The 5-th smallest number is 3 (1, 2, 2, 3, 3). 這題我試了很多方法，不管怎麼樣總是不夠周延，最後看了別人的解法，使用 binary search ，實在太厲害了完全想不到。看懂了之後寫了個 python 的版本，方法簡單來說就是利用二分搜尋法，找出中間值 mid ，接著計算每一列小於等於 mid 的個數的和，若總數小於 k ，代表值太小了還要再多一點；若總數大於 k ，代表值太大了要小一點，迴圈重複直到 low &lt; high 的時候代表找到了。 1234567891011121314151617class Solution: def findKthNumber(self, m, n, k): low, high = 1, m * n + 1 while low &lt; high: mid = (low + high) // 2 c = self.count_less_than_middle(mid, m, n) if c &gt;= k: high = mid else: low = mid + 1 return high def count_less_than_middle(self, middle, m, n): num = 0 for i in range(1, m + 1): num += min(middle // i, n) return num 結果最後在時間內只有解出一題，排名只有 1157 / 2554，剩下的都是比賽結束後才想出來QQ，太慘烈了。看來在下做的題目還不夠多，看到題目沒辦法馬上有 sense 要用什麼方式解，只好先來閉關修煉一下了QQ 。]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>LeetCode Weekly Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#566 Reshape the Matrix]]></title>
    <url>%2F2017%2F08%2F27%2FLeetCode-566-Reshape-the-Matrix%2F</url>
    <content type="text"><![CDATA[問題給定一個二維的矩陣以及正整數 r 與 c ，將此矩陣轉為 r * c 的矩陣。若無法轉換，則輸出原本的矩陣。 輸入nums = [[1,2], [3,4]] r = 1, c = 4 輸出[[1,2,3,4]] 方法檢查兩個矩陣的行數與列數相乘的結果是否相同，若成立代表這兩個矩陣的元素個數相同，也就是兩個矩陣能夠互相轉換。接著將原本 2D 的矩陣轉成 1D ，這樣在轉換成另一個大小的矩陣時會比較方便，只要依序取出即可。 1234567891011121314class Solution(object): def matrixReshape(self, nums, r, c): row = len(nums) col = len(nums[0]) if row * col == r * c: one_d_array = [nums[i][j] for i in range(row) for j in range(col)] ans = [[0 for j in range(c)] for i in range(r)] count_element = 0 for i in range(r): for j in range(c): ans[i][j] = one_d_array[count_element] count_element += 1 return ans return nums]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#561 Array Partition I]]></title>
    <url>%2F2017%2F08%2F26%2FLeetCode-561-Array-Partition-I%2F</url>
    <content type="text"><![CDATA[問題給一個長度為 2n 的整數陣列，將陣列的值兩兩配對，使得所有 min(ai, bi) 的和愈大愈好 (0 &lt;= i &lt;= n) 。 輸入[1,4,3,2] 輸出4 方法這題直覺就是先將陣列排序之後再取奇數項相加就好。 sort: [1,2,3,4] min(1, 2) + min(3, 4) = 4 1234567class Solution(object): def arrayPairSum(self, nums): summation = 0 for i, v in enumerate(sorted(nums)): if i % 2 == 0: summation += v return summation 在底下討論版找到了一行解決的 code ，完全體現 python 簡約的風格，太神啦! 123class Solution(object): def arrayPairSum(self, nums): return sum(sorted(nums)[::2])]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#461 Hamming Distance]]></title>
    <url>%2F2017%2F08%2F26%2FLeetCode-461-Hamming-Distance%2F</url>
    <content type="text"><![CDATA[問題給兩個整數x與y，計算兩者的 Hamming Distance 。 輸入x = 1, y = 4 輸出2 方法所謂的 Hamming Distance 就是兩個string中有幾個相異的位元個數，舉個例子： 1 = (0 0 0 1) 4 = (0 1 0 0) ↑ ↑ 1 跟 4 有兩個相異的位元個數，因此 1 跟 4 的 Hamming Distance 為 2 。我們可以很直覺的想到可以用 exclusive or 簡單的計算出來，也就是兩個 bit 相同時輸出 0 ，兩個 bit 相異時輸出 1 ，最後再計算總共有幾位數為 1 即可。123class Solution(object): def hammingDistance(self, x, y): return bin(x^y).count("1")]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Hamming Distance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode#1 Two Sums]]></title>
    <url>%2F2017%2F08%2F26%2FLeetCode-1-Two-Sums%2F</url>
    <content type="text"><![CDATA[問題給定一個整數的陣列nums，其中有兩個數的和會等於目標target，回傳他們的位置，且同個位置不能重複選取。 輸入nums = [2, 7, 11, 15] target = 9 輸出[0, 1] 方法 Brute Force Hash Table 第一種方法就是直接使用暴力法，把陣列裡面的元素都加加看，但是時間複雜度會到O(n2)。 123456class Solution(object): def twoSum(self, nums, target): for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j] 居然吃了一發TLE，沒想到第一題就玩真的，只好另尋他法了。這時想到python中相當好用的dictionary，第二種方法就是利用雜湊表將讀到的 index 及 value 紀錄下來，即可在讀入一個新的數之後查看這個數的 complement 是否在 table 當中，這樣就可以完美找到一組解啦。因為使用了dictionary，所以查表的時間只要O(1)，最後時間複雜度降到了O(n)，當然也就順利通過了！ 12345678class Solution(object): def twoSum(self, nums, target): dic = &#123;&#125; for i, n in enumerate(nums): if target - n in dic: return [dic[target - n], i] else: dic[n] = i]]></content>
      <categories>
        <category>程式解題</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
